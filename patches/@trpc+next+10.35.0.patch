# `awaitPrespassRender` fn added
# meta context added
diff --git a/node_modules/@trpc/next/dist/createTRPCNext.d.ts b/node_modules/@trpc/next/dist/createTRPCNext.d.ts
index a50d3bf..bcbe3b1 100644
--- a/node_modules/@trpc/next/dist/createTRPCNext.d.ts
+++ b/node_modules/@trpc/next/dist/createTRPCNext.d.ts
@@ -14,5 +14,5 @@ export interface CreateTRPCNextBase<TRouter extends AnyRouter, TSSRContext exten
  * @internal
  */
 export type CreateTRPCNext<TRouter extends AnyRouter, TSSRContext extends NextPageContext, TFlags> = ProtectedIntersection<CreateTRPCNextBase<TRouter, TSSRContext>, DecoratedProcedureRecord<TRouter['_def']['record'], TFlags>>;
-export declare function createTRPCNext<TRouter extends AnyRouter, TSSRContext extends NextPageContext = NextPageContext, TFlags = null>(opts: WithTRPCNoSSROptions<TRouter> | WithTRPCSSROptions<TRouter>): CreateTRPCNext<TRouter, TSSRContext, TFlags>;
+export declare function createTRPCNext<TRouter extends AnyRouter, TMetaContext = null, TSSRContext extends NextPageContext = NextPageContext, TFlags = null>(opts: WithTRPCNoSSROptions<TRouter, TMetaContext> | WithTRPCSSROptions<TRouter, TMetaContext>): CreateTRPCNext<TRouter, TSSRContext, TFlags>;
 //# sourceMappingURL=createTRPCNext.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@trpc/next/dist/createTRPCNext.d.ts.map b/node_modules/@trpc/next/dist/createTRPCNext.d.ts.map
index 6bc1aac..33a2b62 100644
--- a/node_modules/@trpc/next/dist/createTRPCNext.d.ts.map
+++ b/node_modules/@trpc/next/dist/createTRPCNext.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"createTRPCNext.d.ts","sourceRoot":"","sources":["../src/createTRPCNext.tsx"],"names":[],"mappings":"AAEA,OAAO,EAIL,qBAAqB,EACrB,wBAAwB,EACxB,cAAc,EACf,MAAM,0BAA0B,CAAC;AAClC,OAAO,EAAE,SAAS,EAAE,qBAAqB,EAAE,MAAM,cAAc,CAAC;AAEhE,OAAO,EAAE,eAAe,EAAE,MAAM,YAAY,CAAC;AAE7C,OAAO,EAAE,QAAQ,EAAE,oBAAoB,EAAE,kBAAkB,EAAE,MAAM,YAAY,CAAC;AAEhF;;GAEG;AACH,MAAM,WAAW,kBAAkB,CACjC,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe;IAEnC,UAAU,IAAI,qBAAqB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;IAC1D,QAAQ,EAAE,UAAU,CAAC,OAAO,QAAQ,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC,CAAC;IAC5D,UAAU,EAAE,cAAc,CAAC,OAAO,CAAC,CAAC;CACrC;AAED;;GAEG;AACH,MAAM,MAAM,cAAc,CACxB,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe,EACnC,MAAM,IACJ,qBAAqB,CACvB,kBAAkB,CAAC,OAAO,EAAE,WAAW,CAAC,EACxC,wBAAwB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,EAAE,MAAM,CAAC,CAC5D,CAAC;AAEF,wBAAgB,cAAc,CAC5B,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe,GAAG,eAAe,EACrD,MAAM,GAAG,IAAI,EAEb,IAAI,EAAE,oBAAoB,CAAC,OAAO,CAAC,GAAG,kBAAkB,CAAC,OAAO,CAAC,GAChE,cAAc,CAAC,OAAO,EAAE,WAAW,EAAE,MAAM,CAAC,CA2B9C"}
\ No newline at end of file
+{"version":3,"file":"createTRPCNext.d.ts","sourceRoot":"","sources":["../src/createTRPCNext.tsx"],"names":[],"mappings":"AAEA,OAAO,EAIL,qBAAqB,EACrB,wBAAwB,EACxB,cAAc,EACf,MAAM,0BAA0B,CAAC;AAClC,OAAO,EAAE,SAAS,EAAE,qBAAqB,EAAE,MAAM,cAAc,CAAC;AAEhE,OAAO,EAAE,eAAe,EAAE,MAAM,YAAY,CAAC;AAE7C,OAAO,EAAE,QAAQ,EAAE,oBAAoB,EAAE,kBAAkB,EAAE,MAAM,YAAY,CAAC;AAEhF;;GAEG;AACH,MAAM,WAAW,kBAAkB,CACjC,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe;IAEnC,UAAU,IAAI,qBAAqB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;IAC1D,QAAQ,EAAE,UAAU,CAAC,OAAO,QAAQ,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC,CAAC;IAC5D,UAAU,EAAE,cAAc,CAAC,OAAO,CAAC,CAAC;CACrC;AAED;;GAEG;AACH,MAAM,MAAM,cAAc,CACxB,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe,EACnC,MAAM,IACJ,qBAAqB,CACvB,kBAAkB,CAAC,OAAO,EAAE,WAAW,CAAC,EACxC,wBAAwB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,EAAE,MAAM,CAAC,CAC5D,CAAC;AAEF,wBAAgB,cAAc,CAC5B,OAAO,SAAS,SAAS,EACzB,YAAY,GAAG,IAAI,EACnB,WAAW,SAAS,eAAe,GAAG,eAAe,EACrD,MAAM,GAAG,IAAI,EAEb,IAAI,EACA,oBAAoB,CAAC,OAAO,EAAE,YAAY,CAAC,GAC3C,kBAAkB,CAAC,OAAO,EAAE,YAAY,CAAC,GAC5C,cAAc,CAAC,OAAO,EAAE,WAAW,EAAE,MAAM,CAAC,CA2B9C"}
\ No newline at end of file
diff --git a/node_modules/@trpc/next/dist/index.js b/node_modules/@trpc/next/dist/index.js
index d062a0b..0f347de 100644
--- a/node_modules/@trpc/next/dist/index.js
+++ b/node_modules/@trpc/next/dist/index.js
@@ -32,16 +32,34 @@ function transformQueryOrMutationCacheErrors(result) {
     }
     return result;
 }
+const waitUntilNoObservers = (queryClient)=>new Promise((resolve)=>{
+        const unsub = queryClient.getQueryCache().subscribe((event)=>{
+            if (event?.query.getObserversCount() === 0) {
+                resolve();
+                unsub();
+            }
+        });
+    });
+const awaitUntilResolved = async (queryClient)=>{
+    if (!queryClient.isFetching()) {
+        // the render didn't cause the queryClient to fetch anything
+        return true;
+    }
+    await waitUntilNoObservers(queryClient);
+    return false;
+};
 function withTRPC(opts) {
-    const { config: getClientConfig  } = opts;
+    const { config: getClientConfig , meta: getMeta = ()=>null , awaitPrespassRender =awaitUntilResolved ,  } = opts;
     return (AppOrPage)=>{
         const trpc = reactQuery.createReactQueryHooks(opts);
-        const WithTRPC = (props)=>{
+        const WithTRPC = ({ meta , ...props })=>{
             const [prepassProps] = React.useState(()=>{
                 if (props.trpc) {
                     return props.trpc;
                 }
-                const config = getClientConfig({});
+                const config = getClientConfig({
+                    meta
+                });
                 const queryClient = shared.getQueryClient(config);
                 const trpcClient = trpc.createClient(config);
                 return {
@@ -83,14 +101,16 @@ function withTRPC(opts) {
                         ...pageProps
                     };
                 }
+                const metaContext = getMeta(ctx);
                 const getAppTreeProps = (props)=>isApp ? {
-                        pageProps: props
+                        pageProps: props,
+                        meta: metaContext
                     } : props;
                 if (typeof window !== 'undefined' || !opts.ssr) {
                     return getAppTreeProps(pageProps);
                 }
                 const config = getClientConfig({
-                    ctx
+                    meta: metaContext
                 });
                 const trpcClient = reactQuery.createTRPCClient(config);
                 const queryClient = shared.getQueryClient(config);
@@ -110,18 +130,11 @@ function withTRPC(opts) {
                 while(true){
                     // render full tree
                     await ssrPrepass__default["default"](/*#__PURE__*/ React.createElement(AppTree, prepassProps));
-                    if (!queryClient.isFetching()) {
+                    // wait until the query cache has settled it's promises
+                    const isResolved = await awaitPrespassRender(queryClient);
+                    if (isResolved) {
                         break;
                     }
-                    // wait until the query cache has settled it's promises
-                    await new Promise((resolve)=>{
-                        const unsub = queryClient.getQueryCache().subscribe((event)=>{
-                            if (event?.query.getObserversCount() === 0) {
-                                resolve();
-                                unsub();
-                            }
-                        });
-                    });
                 }
                 const dehydratedCache = reactQuery$1.dehydrate(queryClient, {
                     shouldDehydrateQuery () {
@@ -192,4 +205,5 @@ function createTRPCNext(opts) {
 }
 
 exports.createTRPCNext = createTRPCNext;
+exports.waitUntilNoObservers = waitUntilNoObservers;
 exports.withTRPC = withTRPC;
diff --git a/node_modules/@trpc/next/dist/index.mjs b/node_modules/@trpc/next/dist/index.mjs
index 2cc5de2..204900c 100644
--- a/node_modules/@trpc/next/dist/index.mjs
+++ b/node_modules/@trpc/next/dist/index.mjs
@@ -23,16 +23,34 @@ function transformQueryOrMutationCacheErrors(result) {
     }
     return result;
 }
+const waitUntilNoObservers = (queryClient)=>new Promise((resolve)=>{
+        const unsub = queryClient.getQueryCache().subscribe((event)=>{
+            if (event?.query.getObserversCount() === 0) {
+                resolve();
+                unsub();
+            }
+        });
+    });
+const awaitUntilResolved = async (queryClient)=>{
+    if (!queryClient.isFetching()) {
+        // the render didn't cause the queryClient to fetch anything
+        return true;
+    }
+    await waitUntilNoObservers(queryClient);
+    return false;
+};
 function withTRPC(opts) {
-    const { config: getClientConfig  } = opts;
+    const { config: getClientConfig , meta: getMeta = ()=>null , awaitPrespassRender =awaitUntilResolved ,  } = opts;
     return (AppOrPage)=>{
         const trpc = createReactQueryHooks(opts);
-        const WithTRPC = (props)=>{
+        const WithTRPC = ({ meta , ...props })=>{
             const [prepassProps] = useState(()=>{
                 if (props.trpc) {
                     return props.trpc;
                 }
-                const config = getClientConfig({});
+                const config = getClientConfig({
+                    meta
+                });
                 const queryClient = getQueryClient(config);
                 const trpcClient = trpc.createClient(config);
                 return {
@@ -74,14 +92,16 @@ function withTRPC(opts) {
                         ...pageProps
                     };
                 }
+                const metaContext = getMeta(ctx);
                 const getAppTreeProps = (props)=>isApp ? {
-                        pageProps: props
+                        pageProps: props,
+                        meta: metaContext
                     } : props;
                 if (typeof window !== 'undefined' || !opts.ssr) {
                     return getAppTreeProps(pageProps);
                 }
                 const config = getClientConfig({
-                    ctx
+                    meta: metaContext
                 });
                 const trpcClient = createTRPCClient(config);
                 const queryClient = getQueryClient(config);
@@ -101,18 +121,11 @@ function withTRPC(opts) {
                 while(true){
                     // render full tree
                     await ssrPrepass(/*#__PURE__*/ createElement(AppTree, prepassProps));
-                    if (!queryClient.isFetching()) {
+                    // wait until the query cache has settled it's promises
+                    const isResolved = await awaitPrespassRender(queryClient);
+                    if (isResolved) {
                         break;
                     }
-                    // wait until the query cache has settled it's promises
-                    await new Promise((resolve)=>{
-                        const unsub = queryClient.getQueryCache().subscribe((event)=>{
-                            if (event?.query.getObserversCount() === 0) {
-                                resolve();
-                                unsub();
-                            }
-                        });
-                    });
                 }
                 const dehydratedCache = dehydrate(queryClient, {
                     shouldDehydrateQuery () {
@@ -182,4 +195,4 @@ function createTRPCNext(opts) {
     });
 }
 
-export { createTRPCNext, withTRPC };
+export { createTRPCNext, waitUntilNoObservers, withTRPC };
diff --git a/node_modules/@trpc/next/dist/withTRPC.d.ts b/node_modules/@trpc/next/dist/withTRPC.d.ts
index 984b95a..397f241 100644
--- a/node_modules/@trpc/next/dist/withTRPC.d.ts
+++ b/node_modules/@trpc/next/dist/withTRPC.d.ts
@@ -1,3 +1,8 @@
+/**
+ * Heavily based on urql's ssr
+ * https://github.com/FormidableLabs/urql/blob/main/packages/next-urql/src/with-urql-client.ts
+ */
+import { QueryClient } from '@tanstack/react-query';
 import type { CreateTRPCClientOptions } from '@trpc/client';
 import { TRPCClientError } from '@trpc/react-query';
 import { CreateTRPCReactOptions, CreateTRPCReactQueryClientConfig } from '@trpc/react-query/shared';
@@ -7,21 +12,26 @@ import { NextComponentType, NextPageContext } from 'next/dist/shared/lib/utils';
 export type WithTRPCConfig<TRouter extends AnyRouter> = CreateTRPCClientOptions<TRouter> & CreateTRPCReactQueryClientConfig & {
     abortOnUnmount?: boolean;
 };
-interface WithTRPCOptions<TRouter extends AnyRouter> extends CreateTRPCReactOptions<TRouter> {
+interface WithTRPCOptions<TRouter extends AnyRouter, TMetaContext> extends CreateTRPCReactOptions<TRouter> {
     config: (info: {
-        ctx?: NextPageContext;
+        meta: TMetaContext;
     }) => WithTRPCConfig<TRouter>;
+    awaitPrespassRender?: (queryClient: QueryClient) => Promise<boolean>;
 }
-export interface WithTRPCSSROptions<TRouter extends AnyRouter> extends WithTRPCOptions<TRouter> {
+interface WithTRPCMetaOptions<TRouter extends AnyRouter, TMetaContext> extends WithTRPCOptions<TRouter, TMetaContext> {
+    meta?: (ctx: NextPageContext) => TMetaContext;
+}
+export interface WithTRPCSSROptions<TRouter extends AnyRouter, TMetaContext> extends WithTRPCMetaOptions<TRouter, TMetaContext> {
     ssr: true;
     responseMeta?: (opts: {
         ctx: NextPageContext;
         clientErrors: TRPCClientError<TRouter>[];
     }) => ResponseMeta;
 }
-export interface WithTRPCNoSSROptions<TRouter extends AnyRouter> extends WithTRPCOptions<TRouter> {
+export interface WithTRPCNoSSROptions<TRouter extends AnyRouter, TMetaContext> extends WithTRPCMetaOptions<TRouter, TMetaContext> {
     ssr?: false;
 }
-export declare function withTRPC<TRouter extends AnyRouter, TSSRContext extends NextPageContext = NextPageContext>(opts: WithTRPCNoSSROptions<TRouter> | WithTRPCSSROptions<TRouter>): (AppOrPage: NextComponentType<any, any, any>) => NextComponentType;
+export declare const waitUntilNoObservers: (queryClient: QueryClient) => Promise<void>;
+export declare function withTRPC<TRouter extends AnyRouter, TMetaContext = null, TSSRContext extends NextPageContext = NextPageContext>(opts: WithTRPCNoSSROptions<TRouter, TMetaContext> | WithTRPCSSROptions<TRouter, TMetaContext>): (AppOrPage: NextComponentType<any, any, any>) => NextComponentType;
 export {};
 //# sourceMappingURL=withTRPC.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@trpc/next/dist/withTRPC.d.ts.map b/node_modules/@trpc/next/dist/withTRPC.d.ts.map
index df573c8..dfa5000 100644
--- a/node_modules/@trpc/next/dist/withTRPC.d.ts.map
+++ b/node_modules/@trpc/next/dist/withTRPC.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"withTRPC.d.ts","sourceRoot":"","sources":["../src/withTRPC.tsx"],"names":[],"mappings":"AAWA,OAAO,KAAK,EAAE,uBAAuB,EAAE,MAAM,cAAc,CAAC;AAC5D,OAAO,EAIL,eAAe,EAEhB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EACL,sBAAsB,EACtB,gCAAgC,EAEjC,MAAM,0BAA0B,CAAC;AAClC,OAAO,KAAK,EAAE,SAAS,EAAe,MAAM,cAAc,CAAC;AAC3D,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACtD,OAAO,EAGL,iBAAiB,EACjB,eAAe,EAChB,MAAM,4BAA4B,CAAC;AA2BpC,MAAM,MAAM,cAAc,CAAC,OAAO,SAAS,SAAS,IAClD,uBAAuB,CAAC,OAAO,CAAC,GAC9B,gCAAgC,GAAG;IACjC,cAAc,CAAC,EAAE,OAAO,CAAC;CAC1B,CAAC;AAEN,UAAU,eAAe,CAAC,OAAO,SAAS,SAAS,CACjD,SAAQ,sBAAsB,CAAC,OAAO,CAAC;IACvC,MAAM,EAAE,CAAC,IAAI,EAAE;QAAE,GAAG,CAAC,EAAE,eAAe,CAAA;KAAE,KAAK,cAAc,CAAC,OAAO,CAAC,CAAC;CACtE;AAED,MAAM,WAAW,kBAAkB,CAAC,OAAO,SAAS,SAAS,CAC3D,SAAQ,eAAe,CAAC,OAAO,CAAC;IAChC,GAAG,EAAE,IAAI,CAAC;IACV,YAAY,CAAC,EAAE,CAAC,IAAI,EAAE;QACpB,GAAG,EAAE,eAAe,CAAC;QACrB,YAAY,EAAE,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC;KAC1C,KAAK,YAAY,CAAC;CACpB;AACD,MAAM,WAAW,oBAAoB,CAAC,OAAO,SAAS,SAAS,CAC7D,SAAQ,eAAe,CAAC,OAAO,CAAC;IAChC,GAAG,CAAC,EAAE,KAAK,CAAC;CACb;AAED,wBAAgB,QAAQ,CACtB,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe,GAAG,eAAe,EACrD,IAAI,EAAE,oBAAoB,CAAC,OAAO,CAAC,GAAG,kBAAkB,CAAC,OAAO,CAAC,eAU9C,kBAAkB,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,KAAG,iBAAiB,CA+KxE"}
\ No newline at end of file
+{"version":3,"file":"withTRPC.d.ts","sourceRoot":"","sources":["../src/withTRPC.tsx"],"names":[],"mappings":"AAAA;;;GAGG;AACH,OAAO,EAIL,WAAW,EAEZ,MAAM,uBAAuB,CAAC;AAC/B,OAAO,KAAK,EAAE,uBAAuB,EAAE,MAAM,cAAc,CAAC;AAC5D,OAAO,EAIL,eAAe,EAEhB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EACL,sBAAsB,EACtB,gCAAgC,EAEjC,MAAM,0BAA0B,CAAC;AAClC,OAAO,KAAK,EAAE,SAAS,EAAe,MAAM,cAAc,CAAC;AAC3D,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACtD,OAAO,EAGL,iBAAiB,EACjB,eAAe,EAChB,MAAM,4BAA4B,CAAC;AA2BpC,MAAM,MAAM,cAAc,CAAC,OAAO,SAAS,SAAS,IAClD,uBAAuB,CAAC,OAAO,CAAC,GAC9B,gCAAgC,GAAG;IACjC,cAAc,CAAC,EAAE,OAAO,CAAC;CAC1B,CAAC;AAEN,UAAU,eAAe,CAAC,OAAO,SAAS,SAAS,EAAE,YAAY,CAC/D,SAAQ,sBAAsB,CAAC,OAAO,CAAC;IACvC,MAAM,EAAE,CAAC,IAAI,EAAE;QAAE,IAAI,EAAE,YAAY,CAAA;KAAE,KAAK,cAAc,CAAC,OAAO,CAAC,CAAC;IAClE,mBAAmB,CAAC,EAAE,CAAC,WAAW,EAAE,WAAW,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;CACtE;AAED,UAAU,mBAAmB,CAAC,OAAO,SAAS,SAAS,EAAE,YAAY,CACnE,SAAQ,eAAe,CAAC,OAAO,EAAE,YAAY,CAAC;IAC9C,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,eAAe,KAAK,YAAY,CAAC;CAC/C;AAED,MAAM,WAAW,kBAAkB,CAAC,OAAO,SAAS,SAAS,EAAE,YAAY,CACzE,SAAQ,mBAAmB,CAAC,OAAO,EAAE,YAAY,CAAC;IAClD,GAAG,EAAE,IAAI,CAAC;IACV,YAAY,CAAC,EAAE,CAAC,IAAI,EAAE;QACpB,GAAG,EAAE,eAAe,CAAC;QACrB,YAAY,EAAE,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC;KAC1C,KAAK,YAAY,CAAC;CACpB;AACD,MAAM,WAAW,oBAAoB,CAAC,OAAO,SAAS,SAAS,EAAE,YAAY,CAC3E,SAAQ,mBAAmB,CAAC,OAAO,EAAE,YAAY,CAAC;IAClD,GAAG,CAAC,EAAE,KAAK,CAAC;CACb;AAED,eAAO,MAAM,oBAAoB,gBAAiB,WAAW,kBAQzD,CAAC;AAaL,wBAAgB,QAAQ,CACtB,OAAO,SAAS,SAAS,EACzB,YAAY,GAAG,IAAI,EACnB,WAAW,SAAS,eAAe,GAAG,eAAe,EAErD,IAAI,EACA,oBAAoB,CAAC,OAAO,EAAE,YAAY,CAAC,GAC3C,kBAAkB,CAAC,OAAO,EAAE,YAAY,CAAC,eAe1B,kBAAkB,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,KAAG,iBAAiB,CAyKxE"}
\ No newline at end of file
diff --git a/node_modules/@trpc/next/src/createTRPCNext.tsx b/node_modules/@trpc/next/src/createTRPCNext.tsx
index 13637f5..3c9f843 100644
--- a/node_modules/@trpc/next/src/createTRPCNext.tsx
+++ b/node_modules/@trpc/next/src/createTRPCNext.tsx
@@ -40,10 +40,11 @@ export type CreateTRPCNext<
 
 export function createTRPCNext<
   TRouter extends AnyRouter,
+  TMetaContext = unknown,
   TSSRContext extends NextPageContext = NextPageContext,
   TFlags = null,
 >(
-  opts: WithTRPCNoSSROptions<TRouter> | WithTRPCSSROptions<TRouter>,
+  opts: WithTRPCNoSSROptions<TRouter, TMetaContext> | WithTRPCSSROptions<TRouter, TMetaContext>,
 ): CreateTRPCNext<TRouter, TSSRContext, TFlags> {
   const hooks = createHooksInternal<TRouter, TSSRContext>(opts);
 
diff --git a/node_modules/@trpc/next/src/withTRPC.tsx b/node_modules/@trpc/next/src/withTRPC.tsx
index 3d0e4eb..0f5064b 100644
--- a/node_modules/@trpc/next/src/withTRPC.tsx
+++ b/node_modules/@trpc/next/src/withTRPC.tsx
@@ -62,29 +62,54 @@ export type WithTRPCConfig<TRouter extends AnyRouter> =
       abortOnUnmount?: boolean;
     };
 
-interface WithTRPCOptions<TRouter extends AnyRouter>
+interface WithTRPCOptions<TRouter extends AnyRouter, TMetaContext = unknown>
   extends CreateTRPCReactOptions<TRouter> {
-  config: (info: { ctx?: NextPageContext }) => WithTRPCConfig<TRouter>;
+  config: (info: { meta: TMetaContext }) => WithTRPCConfig<TRouter>;
+  meta: (ctx: NextPageContext) => TMetaContext;
+  awaitPrespassRender?: (queryClient: QueryClient) => Promise<boolean>;
 }
 
-export interface WithTRPCSSROptions<TRouter extends AnyRouter>
-  extends WithTRPCOptions<TRouter> {
+export interface WithTRPCSSROptions<TRouter extends AnyRouter, TMetaContext = unknown>
+  extends WithTRPCOptions<TRouter, TMetaContext> {
   ssr: true;
   responseMeta?: (opts: {
     ctx: NextPageContext;
     clientErrors: TRPCClientError<TRouter>[];
   }) => ResponseMeta;
 }
-export interface WithTRPCNoSSROptions<TRouter extends AnyRouter>
-  extends WithTRPCOptions<TRouter> {
+export interface WithTRPCNoSSROptions<TRouter extends AnyRouter, TMetaContext = unknown>
+  extends WithTRPCOptions<TRouter, TMetaContext> {
   ssr?: false;
 }
 
+const awaitUntilResolved = async (
+  queryClient: QueryClient,
+): Promise<boolean> => {
+  if (!queryClient.isFetching()) {
+    // the render didn't cause the queryClient to fetch anything
+    return true;
+  }
+  await new Promise<void>((resolve) => {
+    const unsub = queryClient.getQueryCache().subscribe((event) => {
+      if (event?.query.getObserversCount() === 0) {
+        resolve();
+        unsub();
+      }
+    });
+  });
+  return false;
+};
+
 export function withTRPC<
   TRouter extends AnyRouter,
+  TMetaContext = unknown,
   TSSRContext extends NextPageContext = NextPageContext,
->(opts: WithTRPCNoSSROptions<TRouter> | WithTRPCSSROptions<TRouter>) {
-  const { config: getClientConfig } = opts;
+>(opts: WithTRPCNoSSROptions<TRouter, TMetaContext> | WithTRPCSSROptions<TRouter, TMetaContext>) {
+  const {
+    config: getClientConfig,
+    meta: getMeta,
+    awaitPrespassRender = awaitUntilResolved,
+  } = opts;
 
   type TRPCPrepassProps = {
     config: WithTRPCConfig<TRouter>;
@@ -96,17 +121,19 @@ export function withTRPC<
   return (AppOrPage: NextComponentType<any, any, any>): NextComponentType => {
     const trpc = createReactQueryHooks<TRouter, TSSRContext>(opts);
 
-    const WithTRPC = (
-      props: AppPropsType<NextRouter, any> & {
-        trpc?: TRPCPrepassProps;
-      },
-    ) => {
+    const WithTRPC = ({
+      meta,
+      ...props
+    }: AppPropsType<NextRouter, any> & {
+      trpc?: TRPCPrepassProps;
+      meta: TMetaContext;
+    }) => {
       const [prepassProps] = useState(() => {
         if (props.trpc) {
           return props.trpc;
         }
 
-        const config = getClientConfig({});
+        const config = getClientConfig({ meta });
         const queryClient = getQueryClient(config);
         const trpcClient = trpc.createClient(config);
         return {
@@ -168,14 +195,15 @@ export function withTRPC<
             ...pageProps,
           };
         }
+        const metaContext = getMeta(ctx);
         const getAppTreeProps = (props: Record<string, unknown>) =>
-          isApp ? { pageProps: props } : props;
+          isApp ? { pageProps: props, meta: metaContext } : props;
 
         if (typeof window !== 'undefined' || !opts.ssr) {
           return getAppTreeProps(pageProps);
         }
 
-        const config = getClientConfig({ ctx });
+        const config = getClientConfig({ meta: metaContext });
         const trpcClient = createTRPCClient(config);
         const queryClient = getQueryClient(config);
 
@@ -196,20 +224,11 @@ export function withTRPC<
         while (true) {
           // render full tree
           await ssrPrepass(createElement(AppTree, prepassProps as any));
-          if (!queryClient.isFetching()) {
-            // the render didn't cause the queryClient to fetch anything
+          // wait until the query cache has settled it's promises
+          const isResolved = await awaitPrespassRender(queryClient);
+          if (isResolved) {
             break;
           }
-
-          // wait until the query cache has settled it's promises
-          await new Promise<void>((resolve) => {
-            const unsub = queryClient.getQueryCache().subscribe((event) => {
-              if (event?.query.getObserversCount() === 0) {
-                resolve();
-                unsub();
-              }
-            });
-          });
         }
         const dehydratedCache = dehydrate(queryClient, {
           shouldDehydrateQuery() {
