# `awaitPrespassRender` fn added
# meta context added
diff --git a/dist/createTRPCNext.d.ts b/dist/createTRPCNext.d.ts
index a50d3bf..a8b5c1b 100644
--- a/dist/createTRPCNext.d.ts
+++ b/dist/createTRPCNext.d.ts
@@ -14,5 +14,5 @@ export interface CreateTRPCNextBase<TRouter extends AnyRouter, TSSRContext exten
  * @internal
  */
 export type CreateTRPCNext<TRouter extends AnyRouter, TSSRContext extends NextPageContext, TFlags> = ProtectedIntersection<CreateTRPCNextBase<TRouter, TSSRContext>, DecoratedProcedureRecord<TRouter['_def']['record'], TFlags>>;
-export declare function createTRPCNext<TRouter extends AnyRouter, TSSRContext extends NextPageContext = NextPageContext, TFlags = null>(opts: WithTRPCNoSSROptions<TRouter> | WithTRPCSSROptions<TRouter>): CreateTRPCNext<TRouter, TSSRContext, TFlags>;
+export declare function createTRPCNext<TRouter extends AnyRouter, TMetaContext = null, TSSRContext extends NextPageContext = NextPageContext, TFlags = null>(opts: WithTRPCNoSSROptions<TRouter, TMetaContext, TSSRContext> | WithTRPCSSROptions<TRouter, TMetaContext, TSSRContext>): CreateTRPCNext<TRouter, TSSRContext, TFlags>;
 //# sourceMappingURL=createTRPCNext.d.ts.map
\ No newline at end of file
diff --git a/dist/createTRPCNext.d.ts.map b/dist/createTRPCNext.d.ts.map
index 6bc1aac..f6eed72 100644
--- a/dist/createTRPCNext.d.ts.map
+++ b/dist/createTRPCNext.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"createTRPCNext.d.ts","sourceRoot":"","sources":["../src/createTRPCNext.tsx"],"names":[],"mappings":"AAEA,OAAO,EAIL,qBAAqB,EACrB,wBAAwB,EACxB,cAAc,EACf,MAAM,0BAA0B,CAAC;AAClC,OAAO,EAAE,SAAS,EAAE,qBAAqB,EAAE,MAAM,cAAc,CAAC;AAEhE,OAAO,EAAE,eAAe,EAAE,MAAM,YAAY,CAAC;AAE7C,OAAO,EAAE,QAAQ,EAAE,oBAAoB,EAAE,kBAAkB,EAAE,MAAM,YAAY,CAAC;AAEhF;;GAEG;AACH,MAAM,WAAW,kBAAkB,CACjC,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe;IAEnC,UAAU,IAAI,qBAAqB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;IAC1D,QAAQ,EAAE,UAAU,CAAC,OAAO,QAAQ,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC,CAAC;IAC5D,UAAU,EAAE,cAAc,CAAC,OAAO,CAAC,CAAC;CACrC;AAED;;GAEG;AACH,MAAM,MAAM,cAAc,CACxB,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe,EACnC,MAAM,IACJ,qBAAqB,CACvB,kBAAkB,CAAC,OAAO,EAAE,WAAW,CAAC,EACxC,wBAAwB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,EAAE,MAAM,CAAC,CAC5D,CAAC;AAEF,wBAAgB,cAAc,CAC5B,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe,GAAG,eAAe,EACrD,MAAM,GAAG,IAAI,EAEb,IAAI,EAAE,oBAAoB,CAAC,OAAO,CAAC,GAAG,kBAAkB,CAAC,OAAO,CAAC,GAChE,cAAc,CAAC,OAAO,EAAE,WAAW,EAAE,MAAM,CAAC,CA2B9C"}
\ No newline at end of file
+{"version":3,"file":"createTRPCNext.d.ts","sourceRoot":"","sources":["../src/createTRPCNext.tsx"],"names":[],"mappings":"AAEA,OAAO,EAIL,qBAAqB,EACrB,wBAAwB,EACxB,cAAc,EACf,MAAM,0BAA0B,CAAC;AAClC,OAAO,EAAE,SAAS,EAAE,qBAAqB,EAAE,MAAM,cAAc,CAAC;AAEhE,OAAO,EAAE,eAAe,EAAE,MAAM,YAAY,CAAC;AAE7C,OAAO,EAAE,QAAQ,EAAE,oBAAoB,EAAE,kBAAkB,EAAE,MAAM,YAAY,CAAC;AAEhF;;GAEG;AACH,MAAM,WAAW,kBAAkB,CACjC,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe;IAEnC,UAAU,IAAI,qBAAqB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;IAC1D,QAAQ,EAAE,UAAU,CAAC,OAAO,QAAQ,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC,CAAC;IAC5D,UAAU,EAAE,cAAc,CAAC,OAAO,CAAC,CAAC;CACrC;AAED;;GAEG;AACH,MAAM,MAAM,cAAc,CACxB,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe,EACnC,MAAM,IACJ,qBAAqB,CACvB,kBAAkB,CAAC,OAAO,EAAE,WAAW,CAAC,EACxC,wBAAwB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,EAAE,MAAM,CAAC,CAC5D,CAAC;AAEF,wBAAgB,cAAc,CAC5B,OAAO,SAAS,SAAS,EACzB,YAAY,GAAG,IAAI,EACnB,WAAW,SAAS,eAAe,GAAG,eAAe,EACrD,MAAM,GAAG,IAAI,EAEb,IAAI,EACA,oBAAoB,CAAC,OAAO,EAAE,YAAY,EAAE,WAAW,CAAC,GACxD,kBAAkB,CAAC,OAAO,EAAE,YAAY,EAAE,WAAW,CAAC,GACzD,cAAc,CAAC,OAAO,EAAE,WAAW,EAAE,MAAM,CAAC,CA2B9C"}
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index d062a0b..10c9cdb 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -32,16 +32,34 @@ function transformQueryOrMutationCacheErrors(result) {
     }
     return result;
 }
+const waitUntilNoObservers = (queryClient)=>new Promise((resolve)=>{
+        const unsub = queryClient.getQueryCache().subscribe((event)=>{
+            if (event?.query.getObserversCount() === 0) {
+                resolve();
+                unsub();
+            }
+        });
+    });
+const awaitUntilResolved = async ({ queryClient  })=>{
+    if (!queryClient.isFetching()) {
+        // the render didn't cause the queryClient to fetch anything
+        return true;
+    }
+    await waitUntilNoObservers(queryClient);
+    return false;
+};
 function withTRPC(opts) {
-    const { config: getClientConfig  } = opts;
+    const { config: getClientConfig , meta: getMeta = ()=>null , awaitPrespassRender =awaitUntilResolved ,  } = opts;
     return (AppOrPage)=>{
         const trpc = reactQuery.createReactQueryHooks(opts);
-        const WithTRPC = (props)=>{
+        const WithTRPC = ({ meta , ...props })=>{
             const [prepassProps] = React.useState(()=>{
                 if (props.trpc) {
                     return props.trpc;
                 }
-                const config = getClientConfig({});
+                const config = getClientConfig({
+                    meta
+                });
                 const queryClient = shared.getQueryClient(config);
                 const trpcClient = trpc.createClient(config);
                 return {
@@ -83,23 +101,26 @@ function withTRPC(opts) {
                         ...pageProps
                     };
                 }
+                const metaContext = getMeta(ctx);
                 const getAppTreeProps = (props)=>isApp ? {
-                        pageProps: props
+                        pageProps: props,
+                        meta: metaContext
                     } : props;
                 if (typeof window !== 'undefined' || !opts.ssr) {
                     return getAppTreeProps(pageProps);
                 }
                 const config = getClientConfig({
-                    ctx
+                    meta: metaContext
                 });
                 const trpcClient = reactQuery.createTRPCClient(config);
                 const queryClient = shared.getQueryClient(config);
+                const ssrContext = ctx;
                 const trpcProp = {
                     config,
                     trpcClient,
                     queryClient,
                     ssrState: 'prepass',
-                    ssrContext: ctx
+                    ssrContext
                 };
                 const prepassProps = {
                     pageProps,
@@ -110,18 +131,14 @@ function withTRPC(opts) {
                 while(true){
                     // render full tree
                     await ssrPrepass__default["default"](/*#__PURE__*/ React.createElement(AppTree, prepassProps));
-                    if (!queryClient.isFetching()) {
-                        break;
-                    }
                     // wait until the query cache has settled it's promises
-                    await new Promise((resolve)=>{
-                        const unsub = queryClient.getQueryCache().subscribe((event)=>{
-                            if (event?.query.getObserversCount() === 0) {
-                                resolve();
-                                unsub();
-                            }
-                        });
+                    const isResolved = await awaitPrespassRender({
+                        ctx: ssrContext,
+                        queryClient
                     });
+                    if (isResolved) {
+                        break;
+                    }
                 }
                 const dehydratedCache = reactQuery$1.dehydrate(queryClient, {
                     shouldDehydrateQuery () {
@@ -192,4 +209,5 @@ function createTRPCNext(opts) {
 }
 
 exports.createTRPCNext = createTRPCNext;
+exports.waitUntilNoObservers = waitUntilNoObservers;
 exports.withTRPC = withTRPC;
diff --git a/dist/index.mjs b/dist/index.mjs
index 2cc5de2..d50f935 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -23,16 +23,34 @@ function transformQueryOrMutationCacheErrors(result) {
     }
     return result;
 }
+const waitUntilNoObservers = (queryClient)=>new Promise((resolve)=>{
+        const unsub = queryClient.getQueryCache().subscribe((event)=>{
+            if (event?.query.getObserversCount() === 0) {
+                resolve();
+                unsub();
+            }
+        });
+    });
+const awaitUntilResolved = async ({ queryClient  })=>{
+    if (!queryClient.isFetching()) {
+        // the render didn't cause the queryClient to fetch anything
+        return true;
+    }
+    await waitUntilNoObservers(queryClient);
+    return false;
+};
 function withTRPC(opts) {
-    const { config: getClientConfig  } = opts;
+    const { config: getClientConfig , meta: getMeta = ()=>null , awaitPrespassRender =awaitUntilResolved ,  } = opts;
     return (AppOrPage)=>{
         const trpc = createReactQueryHooks(opts);
-        const WithTRPC = (props)=>{
+        const WithTRPC = ({ meta , ...props })=>{
             const [prepassProps] = useState(()=>{
                 if (props.trpc) {
                     return props.trpc;
                 }
-                const config = getClientConfig({});
+                const config = getClientConfig({
+                    meta
+                });
                 const queryClient = getQueryClient(config);
                 const trpcClient = trpc.createClient(config);
                 return {
@@ -74,23 +92,26 @@ function withTRPC(opts) {
                         ...pageProps
                     };
                 }
+                const metaContext = getMeta(ctx);
                 const getAppTreeProps = (props)=>isApp ? {
-                        pageProps: props
+                        pageProps: props,
+                        meta: metaContext
                     } : props;
                 if (typeof window !== 'undefined' || !opts.ssr) {
                     return getAppTreeProps(pageProps);
                 }
                 const config = getClientConfig({
-                    ctx
+                    meta: metaContext
                 });
                 const trpcClient = createTRPCClient(config);
                 const queryClient = getQueryClient(config);
+                const ssrContext = ctx;
                 const trpcProp = {
                     config,
                     trpcClient,
                     queryClient,
                     ssrState: 'prepass',
-                    ssrContext: ctx
+                    ssrContext
                 };
                 const prepassProps = {
                     pageProps,
@@ -101,18 +122,14 @@ function withTRPC(opts) {
                 while(true){
                     // render full tree
                     await ssrPrepass(/*#__PURE__*/ createElement(AppTree, prepassProps));
-                    if (!queryClient.isFetching()) {
-                        break;
-                    }
                     // wait until the query cache has settled it's promises
-                    await new Promise((resolve)=>{
-                        const unsub = queryClient.getQueryCache().subscribe((event)=>{
-                            if (event?.query.getObserversCount() === 0) {
-                                resolve();
-                                unsub();
-                            }
-                        });
+                    const isResolved = await awaitPrespassRender({
+                        ctx: ssrContext,
+                        queryClient
                     });
+                    if (isResolved) {
+                        break;
+                    }
                 }
                 const dehydratedCache = dehydrate(queryClient, {
                     shouldDehydrateQuery () {
@@ -182,4 +199,4 @@ function createTRPCNext(opts) {
     });
 }
 
-export { createTRPCNext, withTRPC };
+export { createTRPCNext, waitUntilNoObservers, withTRPC };
diff --git a/dist/withTRPC.d.ts b/dist/withTRPC.d.ts
index 984b95a..a63c5f0 100644
--- a/dist/withTRPC.d.ts
+++ b/dist/withTRPC.d.ts
@@ -1,3 +1,8 @@
+/**
+ * Heavily based on urql's ssr
+ * https://github.com/FormidableLabs/urql/blob/main/packages/next-urql/src/with-urql-client.ts
+ */
+import { QueryClient } from '@tanstack/react-query';
 import type { CreateTRPCClientOptions } from '@trpc/client';
 import { TRPCClientError } from '@trpc/react-query';
 import { CreateTRPCReactOptions, CreateTRPCReactQueryClientConfig } from '@trpc/react-query/shared';
@@ -7,21 +12,29 @@ import { NextComponentType, NextPageContext } from 'next/dist/shared/lib/utils';
 export type WithTRPCConfig<TRouter extends AnyRouter> = CreateTRPCClientOptions<TRouter> & CreateTRPCReactQueryClientConfig & {
     abortOnUnmount?: boolean;
 };
-interface WithTRPCOptions<TRouter extends AnyRouter> extends CreateTRPCReactOptions<TRouter> {
+interface WithTRPCOptions<TRouter extends AnyRouter, TMetaContext, TSSRContext extends NextPageContext> extends CreateTRPCReactOptions<TRouter> {
     config: (info: {
-        ctx?: NextPageContext;
+        meta: TMetaContext;
     }) => WithTRPCConfig<TRouter>;
+    awaitPrespassRender?: (options: {
+        ctx: TSSRContext;
+        queryClient: QueryClient;
+    }) => Promise<boolean>;
 }
-export interface WithTRPCSSROptions<TRouter extends AnyRouter> extends WithTRPCOptions<TRouter> {
+interface WithTRPCMetaOptions<TRouter extends AnyRouter, TMetaContext, TSSRContext extends NextPageContext> extends WithTRPCOptions<TRouter, TMetaContext, TSSRContext> {
+    meta?: (ctx: NextPageContext) => TMetaContext;
+}
+export interface WithTRPCSSROptions<TRouter extends AnyRouter, TMetaContext, TSSRContext extends NextPageContext> extends WithTRPCMetaOptions<TRouter, TMetaContext, TSSRContext> {
     ssr: true;
     responseMeta?: (opts: {
         ctx: NextPageContext;
         clientErrors: TRPCClientError<TRouter>[];
     }) => ResponseMeta;
 }
-export interface WithTRPCNoSSROptions<TRouter extends AnyRouter> extends WithTRPCOptions<TRouter> {
+export interface WithTRPCNoSSROptions<TRouter extends AnyRouter, TMetaContext, TSSRContext extends NextPageContext> extends WithTRPCMetaOptions<TRouter, TMetaContext, TSSRContext> {
     ssr?: false;
 }
-export declare function withTRPC<TRouter extends AnyRouter, TSSRContext extends NextPageContext = NextPageContext>(opts: WithTRPCNoSSROptions<TRouter> | WithTRPCSSROptions<TRouter>): (AppOrPage: NextComponentType<any, any, any>) => NextComponentType;
+export declare const waitUntilNoObservers: (queryClient: QueryClient) => Promise<void>;
+export declare function withTRPC<TRouter extends AnyRouter, TMetaContext = null, TSSRContext extends NextPageContext = NextPageContext>(opts: WithTRPCNoSSROptions<TRouter, TMetaContext, TSSRContext> | WithTRPCSSROptions<TRouter, TMetaContext, TSSRContext>): (AppOrPage: NextComponentType<any, any, any>) => NextComponentType;
 export {};
 //# sourceMappingURL=withTRPC.d.ts.map
\ No newline at end of file
diff --git a/dist/withTRPC.d.ts.map b/dist/withTRPC.d.ts.map
index df573c8..442178c 100644
--- a/dist/withTRPC.d.ts.map
+++ b/dist/withTRPC.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"withTRPC.d.ts","sourceRoot":"","sources":["../src/withTRPC.tsx"],"names":[],"mappings":"AAWA,OAAO,KAAK,EAAE,uBAAuB,EAAE,MAAM,cAAc,CAAC;AAC5D,OAAO,EAIL,eAAe,EAEhB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EACL,sBAAsB,EACtB,gCAAgC,EAEjC,MAAM,0BAA0B,CAAC;AAClC,OAAO,KAAK,EAAE,SAAS,EAAe,MAAM,cAAc,CAAC;AAC3D,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACtD,OAAO,EAGL,iBAAiB,EACjB,eAAe,EAChB,MAAM,4BAA4B,CAAC;AA2BpC,MAAM,MAAM,cAAc,CAAC,OAAO,SAAS,SAAS,IAClD,uBAAuB,CAAC,OAAO,CAAC,GAC9B,gCAAgC,GAAG;IACjC,cAAc,CAAC,EAAE,OAAO,CAAC;CAC1B,CAAC;AAEN,UAAU,eAAe,CAAC,OAAO,SAAS,SAAS,CACjD,SAAQ,sBAAsB,CAAC,OAAO,CAAC;IACvC,MAAM,EAAE,CAAC,IAAI,EAAE;QAAE,GAAG,CAAC,EAAE,eAAe,CAAA;KAAE,KAAK,cAAc,CAAC,OAAO,CAAC,CAAC;CACtE;AAED,MAAM,WAAW,kBAAkB,CAAC,OAAO,SAAS,SAAS,CAC3D,SAAQ,eAAe,CAAC,OAAO,CAAC;IAChC,GAAG,EAAE,IAAI,CAAC;IACV,YAAY,CAAC,EAAE,CAAC,IAAI,EAAE;QACpB,GAAG,EAAE,eAAe,CAAC;QACrB,YAAY,EAAE,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC;KAC1C,KAAK,YAAY,CAAC;CACpB;AACD,MAAM,WAAW,oBAAoB,CAAC,OAAO,SAAS,SAAS,CAC7D,SAAQ,eAAe,CAAC,OAAO,CAAC;IAChC,GAAG,CAAC,EAAE,KAAK,CAAC;CACb;AAED,wBAAgB,QAAQ,CACtB,OAAO,SAAS,SAAS,EACzB,WAAW,SAAS,eAAe,GAAG,eAAe,EACrD,IAAI,EAAE,oBAAoB,CAAC,OAAO,CAAC,GAAG,kBAAkB,CAAC,OAAO,CAAC,eAU9C,kBAAkB,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,KAAG,iBAAiB,CA+KxE"}
\ No newline at end of file
+{"version":3,"file":"withTRPC.d.ts","sourceRoot":"","sources":["../src/withTRPC.tsx"],"names":[],"mappings":"AAAA;;;GAGG;AACH,OAAO,EAIL,WAAW,EAEZ,MAAM,uBAAuB,CAAC;AAC/B,OAAO,KAAK,EAAE,uBAAuB,EAAE,MAAM,cAAc,CAAC;AAC5D,OAAO,EAIL,eAAe,EAEhB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EACL,sBAAsB,EACtB,gCAAgC,EAEjC,MAAM,0BAA0B,CAAC;AAClC,OAAO,KAAK,EAAE,SAAS,EAAe,MAAM,cAAc,CAAC;AAC3D,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACtD,OAAO,EAGL,iBAAiB,EACjB,eAAe,EAChB,MAAM,4BAA4B,CAAC;AA2BpC,MAAM,MAAM,cAAc,CAAC,OAAO,SAAS,SAAS,IAClD,uBAAuB,CAAC,OAAO,CAAC,GAC9B,gCAAgC,GAAG;IACjC,cAAc,CAAC,EAAE,OAAO,CAAC;CAC1B,CAAC;AAEN,UAAU,eAAe,CACvB,OAAO,SAAS,SAAS,EACzB,YAAY,EACZ,WAAW,SAAS,eAAe,CACnC,SAAQ,sBAAsB,CAAC,OAAO,CAAC;IACvC,MAAM,EAAE,CAAC,IAAI,EAAE;QAAE,IAAI,EAAE,YAAY,CAAA;KAAE,KAAK,cAAc,CAAC,OAAO,CAAC,CAAC;IAClE,mBAAmB,CAAC,EAAE,CAAC,OAAO,EAAE;QAC9B,GAAG,EAAE,WAAW,CAAC;QACjB,WAAW,EAAE,WAAW,CAAC;KAC1B,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;CACxB;AAED,UAAU,mBAAmB,CAC3B,OAAO,SAAS,SAAS,EACzB,YAAY,EACZ,WAAW,SAAS,eAAe,CACnC,SAAQ,eAAe,CAAC,OAAO,EAAE,YAAY,EAAE,WAAW,CAAC;IAC3D,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,eAAe,KAAK,YAAY,CAAC;CAC/C;AAED,MAAM,WAAW,kBAAkB,CACjC,OAAO,SAAS,SAAS,EACzB,YAAY,EACZ,WAAW,SAAS,eAAe,CACnC,SAAQ,mBAAmB,CAAC,OAAO,EAAE,YAAY,EAAE,WAAW,CAAC;IAC/D,GAAG,EAAE,IAAI,CAAC;IACV,YAAY,CAAC,EAAE,CAAC,IAAI,EAAE;QACpB,GAAG,EAAE,eAAe,CAAC;QACrB,YAAY,EAAE,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC;KAC1C,KAAK,YAAY,CAAC;CACpB;AACD,MAAM,WAAW,oBAAoB,CACnC,OAAO,SAAS,SAAS,EACzB,YAAY,EACZ,WAAW,SAAS,eAAe,CACnC,SAAQ,mBAAmB,CAAC,OAAO,EAAE,YAAY,EAAE,WAAW,CAAC;IAC/D,GAAG,CAAC,EAAE,KAAK,CAAC;CACb;AAED,eAAO,MAAM,oBAAoB,gBAAiB,WAAW,kBAQzD,CAAC;AAaL,wBAAgB,QAAQ,CACtB,OAAO,SAAS,SAAS,EACzB,YAAY,GAAG,IAAI,EACnB,WAAW,SAAS,eAAe,GAAG,eAAe,EAErD,IAAI,EACA,oBAAoB,CAAC,OAAO,EAAE,YAAY,EAAE,WAAW,CAAC,GACxD,kBAAkB,CAAC,OAAO,EAAE,YAAY,EAAE,WAAW,CAAC,eAevC,kBAAkB,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,KAAG,iBAAiB,CA6KxE"}
\ No newline at end of file
diff --git a/src/createTRPCNext.tsx b/src/createTRPCNext.tsx
index 13637f5..19cb455 100644
--- a/src/createTRPCNext.tsx
+++ b/src/createTRPCNext.tsx
@@ -40,10 +40,13 @@ export type CreateTRPCNext<
 
 export function createTRPCNext<
   TRouter extends AnyRouter,
+  TMetaContext = null,
   TSSRContext extends NextPageContext = NextPageContext,
   TFlags = null,
 >(
-  opts: WithTRPCNoSSROptions<TRouter> | WithTRPCSSROptions<TRouter>,
+  opts:
+    | WithTRPCNoSSROptions<TRouter, TMetaContext, TSSRContext>
+    | WithTRPCSSROptions<TRouter, TMetaContext, TSSRContext>,
 ): CreateTRPCNext<TRouter, TSSRContext, TFlags> {
   const hooks = createHooksInternal<TRouter, TSSRContext>(opts);
 
diff --git a/src/withTRPC.tsx b/src/withTRPC.tsx
index 3d0e4eb..36f8d4e 100644
--- a/src/withTRPC.tsx
+++ b/src/withTRPC.tsx
@@ -62,29 +62,80 @@ export type WithTRPCConfig<TRouter extends AnyRouter> =
       abortOnUnmount?: boolean;
     };
 
-interface WithTRPCOptions<TRouter extends AnyRouter>
-  extends CreateTRPCReactOptions<TRouter> {
-  config: (info: { ctx?: NextPageContext }) => WithTRPCConfig<TRouter>;
+interface WithTRPCOptions<
+  TRouter extends AnyRouter,
+  TMetaContext,
+  TSSRContext extends NextPageContext,
+> extends CreateTRPCReactOptions<TRouter> {
+  config: (info: { meta: TMetaContext }) => WithTRPCConfig<TRouter>;
+  awaitPrespassRender?: (options: {
+    ctx: TSSRContext;
+    queryClient: QueryClient;
+  }) => Promise<boolean>;
+}
+
+interface WithTRPCMetaOptions<
+  TRouter extends AnyRouter,
+  TMetaContext,
+  TSSRContext extends NextPageContext,
+> extends WithTRPCOptions<TRouter, TMetaContext, TSSRContext> {
+  meta?: (ctx: NextPageContext) => TMetaContext;
 }
 
-export interface WithTRPCSSROptions<TRouter extends AnyRouter>
-  extends WithTRPCOptions<TRouter> {
+export interface WithTRPCSSROptions<
+  TRouter extends AnyRouter,
+  TMetaContext,
+  TSSRContext extends NextPageContext,
+> extends WithTRPCMetaOptions<TRouter, TMetaContext, TSSRContext> {
   ssr: true;
   responseMeta?: (opts: {
     ctx: NextPageContext;
     clientErrors: TRPCClientError<TRouter>[];
   }) => ResponseMeta;
 }
-export interface WithTRPCNoSSROptions<TRouter extends AnyRouter>
-  extends WithTRPCOptions<TRouter> {
+export interface WithTRPCNoSSROptions<
+  TRouter extends AnyRouter,
+  TMetaContext,
+  TSSRContext extends NextPageContext,
+> extends WithTRPCMetaOptions<TRouter, TMetaContext, TSSRContext> {
   ssr?: false;
 }
 
+export const waitUntilNoObservers = (queryClient: QueryClient) =>
+  new Promise<void>((resolve) => {
+    const unsub = queryClient.getQueryCache().subscribe((event) => {
+      if (event?.query.getObserversCount() === 0) {
+        resolve();
+        unsub();
+      }
+    });
+  });
+
+const awaitUntilResolved: NonNullable<
+  WithTRPCOptions<AnyRouter, unknown, NextPageContext>['awaitPrespassRender']
+> = async ({ queryClient }) => {
+  if (!queryClient.isFetching()) {
+    // the render didn't cause the queryClient to fetch anything
+    return true;
+  }
+  await waitUntilNoObservers(queryClient);
+  return false;
+};
+
 export function withTRPC<
   TRouter extends AnyRouter,
+  TMetaContext = null,
   TSSRContext extends NextPageContext = NextPageContext,
->(opts: WithTRPCNoSSROptions<TRouter> | WithTRPCSSROptions<TRouter>) {
-  const { config: getClientConfig } = opts;
+>(
+  opts:
+    | WithTRPCNoSSROptions<TRouter, TMetaContext, TSSRContext>
+    | WithTRPCSSROptions<TRouter, TMetaContext, TSSRContext>,
+) {
+  const {
+    config: getClientConfig,
+    meta: getMeta = () => null as TMetaContext,
+    awaitPrespassRender = awaitUntilResolved,
+  } = opts;
 
   type TRPCPrepassProps = {
     config: WithTRPCConfig<TRouter>;
@@ -96,17 +147,19 @@ export function withTRPC<
   return (AppOrPage: NextComponentType<any, any, any>): NextComponentType => {
     const trpc = createReactQueryHooks<TRouter, TSSRContext>(opts);
 
-    const WithTRPC = (
-      props: AppPropsType<NextRouter, any> & {
-        trpc?: TRPCPrepassProps;
-      },
-    ) => {
+    const WithTRPC = ({
+      meta,
+      ...props
+    }: AppPropsType<NextRouter, any> & {
+      trpc?: TRPCPrepassProps;
+      meta: TMetaContext;
+    }) => {
       const [prepassProps] = useState(() => {
         if (props.trpc) {
           return props.trpc;
         }
 
-        const config = getClientConfig({});
+        const config = getClientConfig({ meta });
         const queryClient = getQueryClient(config);
         const trpcClient = trpc.createClient(config);
         return {
@@ -168,23 +221,25 @@ export function withTRPC<
             ...pageProps,
           };
         }
+        const metaContext = getMeta(ctx);
         const getAppTreeProps = (props: Record<string, unknown>) =>
-          isApp ? { pageProps: props } : props;
+          isApp ? { pageProps: props, meta: metaContext } : props;
 
         if (typeof window !== 'undefined' || !opts.ssr) {
           return getAppTreeProps(pageProps);
         }
 
-        const config = getClientConfig({ ctx });
+        const config = getClientConfig({ meta: metaContext });
         const trpcClient = createTRPCClient(config);
         const queryClient = getQueryClient(config);
 
+        const ssrContext = ctx as TSSRContext;
         const trpcProp: TRPCPrepassProps = {
           config,
           trpcClient,
           queryClient,
           ssrState: 'prepass',
-          ssrContext: ctx as TSSRContext,
+          ssrContext,
         };
         const prepassProps = {
           pageProps,
@@ -196,20 +251,14 @@ export function withTRPC<
         while (true) {
           // render full tree
           await ssrPrepass(createElement(AppTree, prepassProps as any));
-          if (!queryClient.isFetching()) {
-            // the render didn't cause the queryClient to fetch anything
-            break;
-          }
-
           // wait until the query cache has settled it's promises
-          await new Promise<void>((resolve) => {
-            const unsub = queryClient.getQueryCache().subscribe((event) => {
-              if (event?.query.getObserversCount() === 0) {
-                resolve();
-                unsub();
-              }
-            });
+          const isResolved = await awaitPrespassRender({
+            ctx: ssrContext,
+            queryClient,
           });
+          if (isResolved) {
+            break;
+          }
         }
         const dehydratedCache = dehydrate(queryClient, {
           shouldDehydrateQuery() {
